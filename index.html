<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pong</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #111;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      font-family: 'Courier New', monospace;
      color: #FFD700;
    }
    h1 {
      font-size: 2rem;
      letter-spacing: 0.3em;
      margin-bottom: 12px;
      color: #FFD700;
    }
    #info {
      font-size: 0.8rem;
      margin-bottom: 16px;
      color: #aaa;
      letter-spacing: 0.1em;
    }
    canvas {
      border: 3px solid #FFD700;
      border-radius: 4px;
      background: #000;
    }
    #message {
      margin-top: 14px;
      font-size: 1rem;
      color: #FFD700;
      letter-spacing: 0.15em;
      min-height: 1.4em;
    }
  </style>
</head>
<body>
  <h1>PONG</h1>
  <div id="info">W / S &nbsp;‚Äî&nbsp; Left Paddle &nbsp;|&nbsp; ‚Üë / ‚Üì &nbsp;‚Äî&nbsp; Right Paddle</div>
  <canvas id="canvas" width="800" height="500"></canvas>
  <div id="message">Press SPACE to start</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const msg = document.getElementById('message');

    const W = canvas.width;
    const H = canvas.height;

    const PADDLE_W = 14;
    const PADDLE_H = 90;
    const BALL_SIZE = 12;
    const PADDLE_SPEED = 6;
    const WIN_SCORE = 7;

    let state = 'idle'; // idle | playing | paused | over

    const ball = { x: W/2, y: H/2, vx: 5, vy: 3 };
    const left  = { x: 20,       y: H/2 - PADDLE_H/2, score: 0 };
    const right = { x: W - 20 - PADDLE_W, y: H/2 - PADDLE_H/2, score: 0 };

    const keys = {};
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === ' ') {
        e.preventDefault();
        if (state === 'idle' || state === 'over') startGame();
        else if (state === 'playing') { state = 'paused'; msg.textContent = 'PAUSED ‚Äî Space to resume'; }
        else if (state === 'paused') { state = 'playing'; msg.textContent = ''; }
      }
    });
    document.addEventListener('keyup', e => { keys[e.key] = false; });

    function resetBall(dir = 1) {
      ball.x = W / 2;
      ball.y = H / 2;
      const angle = (Math.random() * Math.PI / 3) - Math.PI / 6;
      ball.vx = dir * 5 * Math.cos(angle);
      ball.vy = 5 * Math.sin(angle);
    }

    function startGame() {
      left.score = 0;
      right.score = 0;
      left.y = H/2 - PADDLE_H/2;
      right.y = H/2 - PADDLE_H/2;
      resetBall(Math.random() < 0.5 ? 1 : -1);
      state = 'playing';
      msg.textContent = '';
    }

    function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

    function update() {
      if (state !== 'playing') return;

      // Move paddles
      if (keys['w'] || keys['W']) left.y -= PADDLE_SPEED;
      if (keys['s'] || keys['S']) left.y += PADDLE_SPEED;
      if (keys['ArrowUp'])   right.y -= PADDLE_SPEED;
      if (keys['ArrowDown']) right.y += PADDLE_SPEED;

      left.y  = clamp(left.y,  0, H - PADDLE_H);
      right.y = clamp(right.y, 0, H - PADDLE_H);

      // Move ball
      ball.x += ball.vx;
      ball.y += ball.vy;

      // Top / bottom bounce
      if (ball.y - BALL_SIZE/2 <= 0)        { ball.y = BALL_SIZE/2; ball.vy = Math.abs(ball.vy); }
      if (ball.y + BALL_SIZE/2 >= H)        { ball.y = H - BALL_SIZE/2; ball.vy = -Math.abs(ball.vy); }

      // Left paddle collision
      if (ball.x - BALL_SIZE/2 <= left.x + PADDLE_W &&
          ball.x - BALL_SIZE/2 >= left.x &&
          ball.y >= left.y && ball.y <= left.y + PADDLE_H) {
        ball.x = left.x + PADDLE_W + BALL_SIZE/2;
        const hitPos = (ball.y - (left.y + PADDLE_H/2)) / (PADDLE_H/2);
        const angle  = hitPos * (Math.PI / 3);
        const speed  = Math.min(Math.sqrt(ball.vx**2 + ball.vy**2) + 0.3, 14);
        ball.vx =  speed * Math.cos(angle);
        ball.vy =  speed * Math.sin(angle);
      }

      // Right paddle collision
      if (ball.x + BALL_SIZE/2 >= right.x &&
          ball.x + BALL_SIZE/2 <= right.x + PADDLE_W &&
          ball.y >= right.y && ball.y <= right.y + PADDLE_H) {
        ball.x = right.x - BALL_SIZE/2;
        const hitPos = (ball.y - (right.y + PADDLE_H/2)) / (PADDLE_H/2);
        const angle  = hitPos * (Math.PI / 3);
        const speed  = Math.min(Math.sqrt(ball.vx**2 + ball.vy**2) + 0.3, 14);
        ball.vx = -speed * Math.cos(angle);
        ball.vy =  speed * Math.sin(angle);
      }

      // Scoring
      if (ball.x < 0) {
        right.score++;
        checkWin() || resetBall(1);
      }
      if (ball.x > W) {
        left.score++;
        checkWin() || resetBall(-1);
      }
    }

    function checkWin() {
      if (left.score >= WIN_SCORE) {
        state = 'over';
        msg.textContent = 'üèÜ Left Player Wins! ‚Äî Space to restart';
        return true;
      }
      if (right.score >= WIN_SCORE) {
        state = 'over';
        msg.textContent = 'üèÜ Right Player Wins! ‚Äî Space to restart';
        return true;
      }
      return false;
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);

      // Centre dashed line
      ctx.setLineDash([12, 10]);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(W/2, 0);
      ctx.lineTo(W/2, H);
      ctx.stroke();
      ctx.setLineDash([]);

      // Scores
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 48px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(left.score,  W/2 - 80, 60);
      ctx.fillText(right.score, W/2 + 80, 60);

      // Paddles
      ctx.fillStyle = '#FFD700';
      ctx.beginPath();
      roundRect(ctx, left.x,  left.y,  PADDLE_W, PADDLE_H, 4);
      ctx.fill();
      ctx.beginPath();
      roundRect(ctx, right.x, right.y, PADDLE_W, PADDLE_H, 4);
      ctx.fill();

      // Ball
      ctx.fillStyle = '#FFD700';
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_SIZE/2, 0, Math.PI * 2);
      ctx.fill();
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // Draw initial idle screen
    draw();
    loop();
  </script>
</body>
</html>
